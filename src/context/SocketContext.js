import DecodeToken from 'pages/Login/DecodeToken';
import React, { createContext, useContext, useEffect, useState, useMemo, useRef, useCallback } from 'react';
import { io } from 'socket.io-client';
import { IP_SOCKET } from 'utils/Host';
import { IP } from "utils/Host";
import axios from "axios";
import { todayMinusDniGodziny } from 'actions/todayMinusDniGodziny';
  
 let newSocket;
// --- Sta≈Çe konfiguracyjne ---
const STORAGE_TYPE = sessionStorage; 
const TOKEN_KEY = 'token';
const ACTIVITY_INTERVAL = 5000;  
const IDLE_TIMEOUT = 60000;      

// --- ZarzƒÖdzanie Tokenem ---
const getToken = () => STORAGE_TYPE.getItem(TOKEN_KEY); 
const setToken = (token) => STORAGE_TYPE.setItem(TOKEN_KEY, token);
const removeToken = () => STORAGE_TYPE.removeItem(TOKEN_KEY);

// --- Kontekst ---
const SocketContext = createContext(null);
export const useSocket = () => useContext(SocketContext);

// üîë KLUCZOWA ZMIANA: Funkcja do inicjalizacji stanu ID
const getInitialUserId = () => {
    const token = getToken();
    if (token) {
        try {
            // Bezpo≈õrednie dekodowanie tokenu z sessionStorage, je≈õli istnieje
            return DecodeToken(token).id; 
        } catch (e) {
            console.error("B≈ÇƒÖd dekodowania tokenu podczas inicjalizacji:", e);
            removeToken(); // Usu≈Ñ nieprawid≈Çowy/uszkodzony token
            return null;
        }
    }
    return null;
};


// --- G≈Ç√≥wny Dostawca Kontekstu Socket.IO ---
export const SocketProvider = ({ children }) => {

    const [usersIO, setUsersIO] = useState([]);
    const [socket, setSocket] = useState(null);
    const [isConnected, setIsConnected] = useState(false);
    const [isAuthenticated, setIsAuthenticated] = useState(!!getToken());
    const reconnectTimerRef = useRef(null); 

const lokalizacja = useRef(null); 

    // ‚úÖ POPRAWKA: Inicjalizacja currentUserId na podstawie zdekodowanego tokenu
    const [currentUserId, setCurrentUserId] = useState(getInitialUserId()); 
        const [podgladRealizacji, setPodgladRealizacji] = useState([]);
    
    // --- Refy dla ≈õledzenia aktywno≈õci ---
    const idleTimerRef = useRef(null);
    const isThrottledRef = useRef(false);
    const currentStatusRef = useRef('Aktywny'); 

    const updateAuthStatus = (status, token = null) => {
        if (status && token) {
            setToken(token);
            // Ustaw ID po otrzymaniu tokenu
            setCurrentUserId(DecodeToken(token).id); 
        } else if (!status) {
            removeToken();
            // Wyczy≈õƒá ID po wylogowaniu
            setCurrentUserId(null); 
        }
        setIsAuthenticated(status);
    };

    // -----------------------------------------------------------------------
    // SEKCJA 1: ZarzƒÖdzanie LogikƒÖ Aktywno≈õci (Bez zmian logiki)
    // -----------------------------------------------------------------------
    
    const sendActivity = useCallback((status) => {
        if (!socket || !socket.connected || !isConnected || !currentUserId || currentStatusRef.current === status) { 
            return; 
        }
        // alert( "Po≈ÇƒÖczone: " + socket.connected )
        socket.emit('userActivity', { userId: currentUserId, status }); 
        currentStatusRef.current = status; 
        
    }, [socket, isConnected,currentUserId]); 

    const resetIdleTimer = useCallback(() => {
        if (idleTimerRef.current) {
            clearTimeout(idleTimerRef.current);
        }
        idleTimerRef.current = setTimeout(() => {
            sendActivity('Nieaktywny');
        }, IDLE_TIMEOUT);
    }, [sendActivity]);

    const handleActivity = useCallback(() => {
        resetIdleTimer();
        if (isThrottledRef.current) {
            return;
        }
        sendActivity('Aktywny');
        isThrottledRef.current = true;
        setTimeout(() => {
            isThrottledRef.current = false;
        }, ACTIVITY_INTERVAL);
        
    }, [resetIdleTimer, sendActivity]);

    // -----------------------------------------------------------------------
    // SEKCJA 2: Efekt zarzƒÖdzajƒÖcy Po≈ÇƒÖczeniem Socket.IO
    // -----------------------------------------------------------------------
  
      const callPodgladRalizacji = async (od) =>{
        let podglady=[]
        
        const res = await axios.get(IP + "podglad_realizacji_dzien/"+od+"/" + sessionStorage.getItem("token"));

        podglady.push(...res.data[0])
        podglady.push(...res.data[1])
        podglady.push(...res.data[2])
        setPodgladRealizacji(podglady);

        

      }

const logoutIO = useCallback(() => {
        // 1. Zg≈Çoszenie wylogowania do Socket.IO (je≈õli socket istnieje i jest po≈ÇƒÖczony)
        if (socket && isConnected) {
             // Wysy≈Çamy informacjƒô do serwera. Serwer na podstawie 'userId' (lub 'socket.id') 
             // usunie u≈ºytkownika z listy online, a nastƒôpnie Socket.IO sam 
             // obs≈Çu≈ºy roz≈ÇƒÖczenie po stronie serwera.
            socket.emit("logout", { userId: currentUserId,socketId: socket.id }); 
            // üí° Opuszczenie tej linii i poleganie na 'updateAuthStatus' 
            // jest zazwyczaj lepsze, poniewa≈º `useEffect` monitorujƒÖcy token/ID 
            // zajmie siƒô czyszczeniem Socket.IO (disconnect).
            // socket.disconnect(); 
        }

        // 2. Usuniƒôcie tokenu i zresetowanie stanu uwierzytelnienia/ID
        updateAuthStatus(false);
        
        // 3. Wyczy≈õƒá stan specyficzny dla u≈ºytkownika
        setUsersIO([]);
        setPodgladRealizacji([]);
        
        // 4. Czyszczenie timera bezczynno≈õci (kluczowe, by nie wysy≈Çaƒá stanu 'Nieaktywny' po wylogowaniu)
        if (idleTimerRef.current) {
            clearTimeout(idleTimerRef.current);
            idleTimerRef.current = null;
        }
        currentStatusRef.current = 'Wylogowany'; 
        
        // 5. Opcjonalnie: Przekierowanie na stronƒô logowania (zwykle wykonuje siƒô w komponencie wywo≈ÇujƒÖcym lub w globalnym routerze)
        // router.push('/login'); 
    }, [socket, isConnected, currentUserId, updateAuthStatus]); 



    // const logoutIO=()=>{
    //     newSocket.emit("logout",{userId:currentUserId,socketId: socket.id})
    // }


    const handleDisconnect = useCallback((reason, currentSocket) => {
    
    // 1. Sprawdzenie Krytycznych B≈Çƒôd√≥w (np. Serwer nas wyrzuci≈Ç)
    if (reason === 'io server disconnect') {
        // To oznacza, ≈ºe serwer ≈õwiadomie i celowo nas roz≈ÇƒÖczy≈Ç (np. b≈ÇƒÖd tokenu)
        console.error("Serwer Socket.IO nas wyrzuci≈Ç. WYMAGANE RE-LOGOWANIE.");
        updateAuthStatus(false); 
        // W tym przypadku nie pr√≥bujemy siƒô ≈ÇƒÖczyƒá, oczekujemy, ≈ºe router przekieruje
        return;
    }
    
    // 2. Obs≈Çuga Problem√≥w Sieciowych / Timeout√≥w
    if (reason === 'transport close' || reason === 'ping timeout' || reason === 'transport error') {
        // To sƒÖ typowe b≈Çƒôdy sieciowe, kt√≥re wcze≈õniej Socket.IO sam obs≈Çugiwa≈Ç.
        console.info("Roz≈ÇƒÖczenie tymczasowe, ponawiam za 5 sekund.");

        // Zapobiegamy wielokrotnym timerom:
        if (reconnectTimerRef.current) {
            clearTimeout(reconnectTimerRef.current);
        }

        // üí° MANUALNA PR√ìBA PO≈ÅƒÑCZENIA
        reconnectTimerRef.current = setTimeout(() => {
            if (currentSocket) {
                 // Wymuszenie nowego po≈ÇƒÖczenia:
                 currentSocket.connect(); 
            }
        }, 5000); // Spr√≥buj siƒô po≈ÇƒÖczyƒá za 5 sekund
        return;
    }
    
    // 3. Roz≈ÇƒÖczenie Zwyk≈Çe (np. user.disconnect() lub zamykanie karty)
    // W pozosta≈Çych przypadkach po prostu czekamy, a≈º u≈ºytkownik podejmie akcjƒô
    
}, [updateAuthStatus]);


    useEffect(() => {
        const token = getToken();
        
        // üîë NOWY WARUNEK PO≈ÅƒÑCZENIA: U≈ºycie tokena zamiast isAuthenticated
        // Sprawdzenie, czy jest token I jest ID. U≈ºycie tokena, aby by≈Ço
        // zsynchronizowane z autoryzacjƒÖ po stronie serwera.
        if (!token || !currentUserId) {
            // Je≈õli brakuje tokenu lub ID, upewnij siƒô, ≈ºe roz≈ÇƒÖczamy stare gniazdo
            if (socket) {
                socket.disconnect();
                setSocket(null);
            }
            return; 
        }

       newSocket = io(IP_SOCKET, {
            auth: { token: token },
            transports: ['websocket'],
            reconnection: true,
        });

        setSocket(newSocket);
        
        // ... (standardowe listenery Socket.IO) ...
        newSocket.on('connect', () => {
    setIsConnected(true);
    
    // ‚úÖ GWARANCJA, ≈ºe akcja jest wysy≈Çana TYLKO na ≈õwie≈ºe, ≈ºywe gniazdo
    if (currentUserId) {
        // To wywo≈Çuje handleActivity, kt√≥re wysy≈Ça 'Aktywny', resetuje timer 
        // i ustawi listenery DOM (je≈õli zosta≈Çy usuniƒôte/wy≈ÇƒÖczone)
        handleActivity(); 
    }
});
        newSocket.on('disconnect', (reason) => {
        setIsConnected(false);
        // console.warn('Socket.IO zosta≈Ç roz≈ÇƒÖczony. Pow√≥d:', reason);
        
        // üí° Tutaj nastƒôpuje reakcja na roz≈ÇƒÖczenie
        // handleDisconnect(reason, newSocket); 
    });

        newSocket.on('onlineUsers', setUsersIO);
        newSocket.on('connect_error', (err) => {
            console.error('B≈ÇƒÖd po≈ÇƒÖczenia Socket.IO (autoryzacja):', err.message);
            // // Ustawiamy stany na wylogowanie/brak ID

            
            // removeToken(); 
            // setIsAuthenticated(false);
            // setCurrentUserId(null);

                updateAuthStatus(false); 
    
    // CZY≈öCI DODATKOWE STANY
    setUsersIO([]);
    setPodgladRealizacji([]);
        });





            newSocket.on("pobierz_podglad_realizacji", () => {
              // callPodgladRalizacji(todayMinusDniGodziny(1))
              console.log("gdzie jestem: " + lokalizacja.current);
              if (lokalizacja.current == "Panel") {
                console.log("od≈õwie≈ºam tylko panel ");
                callPodgladRalizacji(todayMinusDniGodziny(1));
              }
            });


              newSocket.on("wysylamsocket", (sockets) => {

console.log(sockets)
  });

        // Logika czyszczƒÖca
        return () => {
            newSocket.off('connect');
            newSocket.off('disconnect');
            newSocket.off('connect_error');
            newSocket.off('onlineUsers');
            newSocket.disconnect(); 
            setSocket(null);
            setIsConnected(false);
        };
        // ‚úÖ Zale≈ºno≈õci: React reaguje, gdy zmienia siƒô currentUserId lub token
    }, [currentUserId]); // isAuthenticated jest teraz czƒô≈õciowo zbƒôdny, skupiamy siƒô na currentUserId
    
    // -----------------------------------------------------------------------
    // SEKCJA 3: Efekt zarzƒÖdzajƒÖcy Listenerami DOM (Bez zmian logiki)
    // -----------------------------------------------------------------------
    
    useEffect(() => {
        if (!socket || !currentUserId || !isConnected) {
            clearTimeout(idleTimerRef.current);
            return;
        }

        sendActivity('Aktywny');
        resetIdleTimer();

        const activityEvents = ['mousemove', 'keydown', 'click', 'scroll', 'touchstart'];
        activityEvents.forEach(event => window.addEventListener(event, handleActivity));

        const handleVisibility = () => {
            if (document.hidden) {
                sendActivity('Ukryty'); 
                clearTimeout(idleTimerRef.current);
            } else {
          
                if (socket && !socket.connected) {

            socket.disconnect(); 
            setSocket(null); 
            
        } else if (socket && socket.connected) {
        
            handleActivity(); 
        }
            }
        };

//  const handleVisibility = () => {
// ¬† ¬† ¬† ¬† ¬† ¬† if (document.hidden) {
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† sendActivity('Ukryty'); 
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† clearTimeout(idleTimerRef.current);
// ¬† ¬† ¬† ¬† ¬† ¬† } else {
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // === KLUCZOWA ZMIANA TUTAJ ===
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (socket) {
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // Niezale≈ºnie od socket.connected, zamykamy stare gniazdo.
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // U≈ºywamy .disconnect(), by upewniƒá siƒô, ≈ºe gniazdo zamyka po≈ÇƒÖczenie.
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† socket.disconnect(); 
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† 
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // Ustawienie na null wymusza PONOWNE URUCHOMIENIE Sekcji 2 useEffect, 
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // kt√≥ra tworzy nowe gniazdo z tokenem.
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† setSocket(null); 
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† 
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } else {
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // Je≈õli nie ma gniazda, ale wr√≥cili≈õmy do widoczno≈õci,
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // wywo≈Çaj handleActivity, co przy braku socketu nic nie zrobi,
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // ale uruchomienie Sekcji 2 powinno nastƒÖpiƒá automatycznie, 
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // je≈õli currentUserId jest ustawiony.
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† handleActivity();
// ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
// ¬† ¬† ¬† ¬† ¬† ¬† }
// ¬† ¬† ¬† ¬† };

        document.addEventListener('visibilitychange', handleVisibility);

        return () => {
            activityEvents.forEach(event => window.removeEventListener(event, handleActivity));
            document.removeEventListener('visibilitychange', handleVisibility);
            
            clearTimeout(idleTimerRef.current);
            currentStatusRef.current = 'Aktywny'; 
        };
    }, [socket, currentUserId, isConnected , handleActivity, resetIdleTimer, sendActivity]); 

    // -----------------------------------------------------------------------
    // SEKCJA 4: Kontekst
    // -----------------------------------------------------------------------

    const contextValue = useMemo(() => ({
        socket,
        isConnected,
        isAuthenticated,
        updateAuthStatus,
        usersIO,
        currentUserId,
        logoutIO,
        podgladRealizacji, callPodgladRalizacji,lokalizacja
    }), [socket, isConnected, isAuthenticated, usersIO, currentUserId,podgladRealizacji,callPodgladRalizacji,logoutIO,lokalizacja]);
    
    return (
        <SocketContext.Provider value={contextValue}>
            {children}
        </SocketContext.Provider>
    );
};